# 基于语义地图重建的 Web Agent 架构研究

## 现状分析：Web自动化的两种实现方案

在当前的 Web 自动化领域，存在两种主流方案，但它们各自面临着难以调和的“不可能三角”（速度、通用性、准确性）。

### Web Agent

把一个网站近似成一个树状地图。Agent在每一个分支路口,都要观察,分析,才能前进一步。

- 优点：不必为每个任务写rpa脚本。
- 缺点1:太慢。每前进一步都要调用一次大模型。
- 缺点2:只在局部探索,会迷路。目前的 Agent 是在每一个 Step 都在做概率预测。

在 OnlineMind2Web 中，Browser Use Agent（最好的开源 Web Agent 之一）的成功率只有 30%。

![OnlineMind2Web](./OnlineMind2Web.png)

### rpa如何行动

人直接告诉rpa怎么走。

优点:正确性。速度快。
缺点:每个任务都要写rpa.

## 原因分析

### “确认”是准确性的来源

在日常使用大模型应用时，“确认”环节是不可或缺的。例如 ChatGPT 或 ClaudeCode 很难在初次尝试时就给出完美答案，通常需要用户针对不满意点进行澄清、追问，或让大模型重新生成。这种持续的反馈机制即为“确认”。

Agent 执行流程的缺陷：缺乏确认环节。Agent 在执行时面对的是未知的 DOM 树，Agent进行预测：“基于语义，这个 div 看起来像是一个按钮，预测点击它能成功。”这种预测的本质是在做概率性的猜测。由于缺乏确认环节，一次微小的概率偏离（幻觉）就会导致流程彻底中断或产生错误后果。

RPA 的优势：在 RPA 脚本编写阶段，开发者已经对每一个按钮、每一个选择器（Selector）进行了显式确认。开发者在写 click("#submit_btn") 时，已经亲手点过并确认它能触发提交操作。这种“确认”被永久锁在了代码里。

#### 确认只适合于构建阶段而非执行阶段

在 Agent 执行任务的过程中引入确认机制存在以下问题：

执行阶段确认成本过高：
- 效率瓶颈： 若在每个步骤后都要求人工或自我检查，原本 10 秒的任务可能延长至数分钟。
- 用户疲劳： 若 Agent 频繁询问用户操作是否正确，将失去自动化的核心价值。

无法固化：
- 目前的 Agent 架构通常是“无状态（Stateless）”的。即便本次步骤正确，下次执行相同任务时仍需重新推理。它未能将“已确认正确”的信息转化为可复用的资产。

### “固化”是效率的来源

目前 Agent 的执行是**无状态（Stateless）**的。即便曾成功完成过任务 A，下一次执行相同任务时，依然需要重新解析 DOM、重新推理逻辑。这种“重复思考”造成了计算资源的浪费。

能否借鉴 RPA 的思路，将 Agent 的“思考结果”固化下来？

这就是提出语义地图的原因——将“思考”留在地图构建期，将“速度”留在导航执行期。

## 解决方案

结合 Agent 与 RPA 的优势：将完整的网站语义地图预先提供给 Agent，Agent 仅需调用一次大模型即可生成对应的自动化脚本。

这类似于从“在陌生城市靠直觉摸索”转变为“先进行城市测绘，再根据地图导航”：

现在的agent
- 就像是一个初次来到异国他乡的游客。他能看懂路标（识别按钮），但他脑子里没有这张城市的全局地图。
- 每走到一个十字路口，他都要停下来分析路标 A、B、C 分别代表什么，然后猜测“去火车站应该走左边”。
- 他可能走进了死胡同，或者在原地绕圈。最关键的是，下一次他再去火车站，他还得重新分析一遍，因为他没有把路径固化下来。

构建地图：任务不是为了从 A 点到 B 点，而是为了跑遍全城的每一条路。

RPA：严格执行导航指令的自动驾驶车。它不需要理解为什么左转，它只需要接收指令：Drive(500m) -> TurnLeft -> Stop。速度极快：因为它跳过了所有“思考”和“分析路标”的时间，直接全速前进。

优点：不必为每个任务写rpa。正确性。速度快。
研究点：为网站构建完整地图。

## 如何构建地图

### 对Web应用的解构

Web 应用 $A$ 的最小功能单元是 **Element（元素）**，记为 $e$。一个 Web 应用可以被定义为所有可见及可交互元素的集合：
$$A = \{e_1, e_2, e_3, \dots, e_n\}$$

每个元素 $e_i$ 并非孤立存在，而是由三个维度构成的复合体：

*   **元素标识（Identity - 感知层）：**
    *   **定义：** 机器定位元素的物理路径或特征（如 CSS 选择器、XPath、ID）。
    *   **示例：** `login_button = tab.ele('.form-cut-item-btn')`
    *   **作用：** 解决“它在哪里”的问题，实现机器对页面的**物理感知**。

*   **元素操作（Action - 行动层）：**
    *   **定义：** 对元素施加的状态改变或交互指令。
    *   **示例：** `login_button.click()`
    *   **作用：** 解决“如何交互”的问题，定义交互原语（Click/Input/Select），触发页面的**状态转换**。

*   **元素含义（Semantics - 语义层）：**
    *   **定义：** 描述该元素在业务逻辑中的角色、前置条件及行为后果。
    *   **示例：** “在用户输入凭据后点击此按钮，验证通过后将跳转至【应用市场页】。”
    *   **作用：** 解决“它是做什么的”的问题，赋予操作以**业务含义**。描述业务角色、前置依赖及跳转后果。

通过对 Web 应用中原子元素 $e_i$ 进行上述三要素的建模，便可构建出一张**网页语义地图**，每个元素成为地图上的一个具有业务意义的节点。

### 构建机制

AI与人工相结合的网站语义地图构建。AI自动识别网页元素的语义/ID/可采取的动作。标注员能够进行检查和校正。
- 人类更适合处理元素的前提依赖（即语义层中的高级语义）。例如：只有输入了正确的订单号，才会出现“退款”按钮。
- 当自动探索失败时，自动通知标注员介入。人工点一下，系统自动记录这次“纠偏”，更新地图。
    - （构建地图的过程中，是允许探索和出错的，但实际运行流程自动化时，不行。）

目前进展：纯人工构建原子交互。

为什么不一开始就用AI，因为网页自动化的核心瓶颈在于‘原子交互’的可靠性。目前的AI在这方面表现不佳。

例如，一个目前商用的 web agent, 让其在12306中输入出发地，其错误如下：

```

Thought

用户要求设置出发地为泰安。从截图中可以看到： 1. 左侧有一个"车票"查询表单 2. 表单中有"出发地"字段，显示"简拼/全拼汉字"的占位符 3. 我需要点击出发地输入框，然后输入"泰安" 步骤： 1. 点击出发地输入框 2. 输入"泰安" 3. 确认输入成功

Thought

现在我来点击出发地输入框：

Clicked

点击出发地输入框以便输入泰安

Browser screenshot
Thought

很好！出发地输入框已打开，显示了一个城市列表下拉菜单。我可以看到有多个城市选项。现在我来输入"泰安"来搜索这个城市：

Typed on page

输入"tai"来搜索泰安城市，使用拼音首字母搜索

Browser screenshot
Thought

我看到输入了"tai"后，显示的是北京相关的城市。这不是我们要找的。让我清空输入框，重新输入"泰安"的完整拼音或汉字。让我先清空这个输入框：

Clicked

清空出发地输入框中的内容，以便重新输入

Browser screenshot
Thought

我看到输入框中仍然显示"tai"。让我选中所有文本并删除，然后输入"泰安"：

Typed on page

输入"taian"来搜索泰安城市，使用完整拼音搜索

Browser screenshot
Thought

我看到输入框现在显示"taian"，但下拉列表仍然显示北京相关的城市。让我等待一下，看看是否会更新搜索结果：

Thought

我看到输入框中显示"taian"，但下拉列表仍然显示北京的城市。让我尝试用getText来查看页面的完整结构，看看是否有泰安的选项：

Thought

我看到输入框中已经有"taian"，但搜索结果显示的是北京相关的城市。让我尝试清空输入框，然后用汉字"泰安"来搜索。首先让我点击输入框的清除按钮：

Clicked

清空出发地输入框，以便重新输入泰安

Browser screenshot
Thought

我看到输入框仍然显示"taian"。让我尝试三次点击来全选文本，然后删除：

Clicked

三击选中输入框中的所有文本

Browser screenshot
Thought

很好！我看到输入框已经被清空了。现在让我输入"泰安"的汉字：

Typed on page

输入"泰安"汉字来搜索泰安城市

Browser screenshot
Thought

完美！我看到输入框中现在显示"泰安"，但下拉列表仍然显示北京的城市。让我等待一下，看搜索结果是否会更新：

Thought

我看到输入框中仍然显示"泰安"，但下拉列表仍然显示北京的城市。让我尝试按下键盘的下箭头键来浏览下拉列表中的选项，看是否能找到泰安：

Thought

很好！我看到出发地输入框中已经显示"泰安"了。现在我需要从下拉列表中选择泰安。让我尝试按下键盘的下箭头键来浏览选项，或者直接按回车键来确认选择。让我先尝试按回车键：

Typed on page

按回车键来确认选择泰安作为出发地

Browser screenshot
Thought

我看到输入框中仍然显示"泰安"，但下拉列表仍然显示北京的城市。看起来下拉列表没有更新搜索结果。让我尝试滚动下拉列表，看是否能找到泰安。让我先点击下拉列表中的一个选项，看看是否能看到更多的城市。让我尝试点击下拉列表中的分页按钮来查看更多城市：

Clicked

点击下拉列表中的下一页按钮来查看更多城市

Browser screenshot
Thought

很好！我看到下拉列表已经更新，现在显示的是不同的城市（北京朝阳、北京通州、礼贤、重庆北、重庆东、重庆）。我看到输入框中现在显示"泰安"（用蓝色高亮显示）。现在我需要继续浏览下拉列表来找到泰安。让我继续点击下一页按钮：

Clicked

继续点击下一页按钮来查找泰安城市

Browser screenshot
Thought

我看到下拉列表现在显示的是重庆南、重庆西、绳墩、上海、上海南、上海虹桥等城市。我还没有找到泰安。让我继续点击下一页按钮：

Clicked

继续点击下一页按钮来查找泰安城市

Browser screenshot
Thought

我看到下拉列表现在显示的是上海西、天津北、天津、天津南、天津西、百浪等城市。我还没有找到泰安。让我继续点击下一页按钮：

Clicked

继续点击下一页按钮来查找泰安城市
```

例如，很多像 12306 这样的复杂前端，会监听键盘事件（keydown, keyup）。
input('taian') 通常只是修改了 DOM 元素的 value 属性，没有触发 JS 监听器。
type('taian') 模拟了真实的物理按键，会触发整套事件流。
AI 的局限： 现有的 AI Agent 大多是在静态 HTML 或截图上训练的，它们缺乏对网页动态交互逻辑（Event Listeners）的感知。AI 知道它是输入框，但不知道这个输入框背后有一双“盯着键盘看”的眼睛。

#### 目标：训练AI具备可靠原子交互能力

**训练输入（Input）**
1. 当前页面的简化 DOM (Simplified DOM)：只保留关键标签（input, button, a）及其关键属性（id, class, placeholder, text, aria-label）。
2. 用户的原子意图 (Atomic Intent)：“在出发地输入泰安”。

**训练目标（Label）：**

tab.actions.click('#fromStationText'); tab.actions.type('taian')

网站地图里的元素ID、含义、操作，是AI生成的还是手工编制的，这是根本性的变化。

## 架构

分为两个核心组件：
- Cartographer（绘图员）： 负责遍历网站，构建语义地图。
    - 本质是在逆向工程网站的业务逻辑状态机。
- Navigator（导航员）： 接收任务，查询语义地图，一次性生成 RPA 脚本。

### Cartographer（绘图员）

盲目遍历会导致陷入“死循环”（如万年历组件）。需要利用AI对网站的语义理解能力，优先点击有意义的元素。

### Navigator（导航员）

- 意图理解： 用户输入“我买的鼠标不好用，退钱。”。
    - 用户说“退钱”，地图上叫“申请售后”。Navigator利用AI的语义理解能力，能够正确识别用户的意图。
- 路径查找： 在语义地图中查找从首页到下载页的最短语义路径。
- 脚本生成： 将路径转化为 Python(DrissionPage) 代码一次性执行。

## 本架构的通用性分析

在商业逻辑（Scalability）的角度：如果一个产品需要靠人力堆代码去适配每一个城市、每一个网站，那这个产品的边际成本太高，不具备商业美感。

在工程实践（Reliability）的角度：网页结构千奇百怪、动态加载、反爬机制、不规范的标签（如 12306），现有的 LLM + Web Agent 技术栈确实还没达到“一刀切”的成熟度。

如何处理这个问题并推动项目落地：

1. 重新定义“通用性”：不是“不进行适配”，而是“架构通用”

我们不会为每个网站做硬编码（Hard-coding）式的定制化。

通用性不代表“零适配”，而是“低成本适配”。

完全定制化（RPA时代）： 为 A 站写一套 XPath 脚本，B 站写一套。网站一改版，脚本全挂。

理想通用化（AGI时代）： 像人一样，看到任何网页都能直接上手。目前做不到（比如 12306 例子）。

折中方案： **“通用大脑+插件式网站地图”**。

核心逻辑（如：拆解任务、处理异常、分析状态）是通用的。

针对不同业务系统的网站，只需要提供一份轻量级的**“领域描述文件（Schema/Metadata）”**，而不是重写代码。

## 意义

- 当拥有了数百个政务系统的完整地图时，这本身就是巨大的数据资产。
    - 可进行跨业务系统的流程自动化。
- 当拥有了网站的完整地图时，相当于为通用大模型注入了领域专业知识。地图本身就是模型能力的补丁。