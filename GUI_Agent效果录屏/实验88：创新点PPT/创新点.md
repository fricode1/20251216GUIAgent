# 基于语义地图重建的 Web Agent 架构研究

## 现状分析：Web自动化的两种实现方案

在当前的 Web 自动化领域，存在两种主流方案，但它们各自面临着难以调和的“不可能三角”（速度、通用性、准确性）。

### Web Agent

把一个网站近似成一个树状地图。Agent在每一个分支路口,都要观察,分析,才能前进一步。

- 优点：不必为每个任务写rpa脚本。
- 缺点1:太慢。每前进一步都要调用一次大模型。
- 缺点2:只在局部探索,会迷路。目前的 Agent 是在每一个 Step 都在做概率预测。

### rpa如何行动

人直接告诉rpa怎么走。

优点:正确性。速度快。
缺点:每个任务都要写rpa.

## 原因分析

### “确认”是准确性的来源

日常使用大模型应用时，“确认”是不可或缺的：ChatGPT/ClaudeCode很难第一次就给出我们想要的答案，往往是：大模型生成一个结果，我们将不满意的点进行澄清，让大模型继续生成，或者清空历史对话让大模型重新生成——这就是确认的环节。

Agent执行流程操作：没有确认环节。Agent 在执行时，面对的是未知的 DOM 树。它在做概率预测：“根据语义，这个 div 看起来像是个按钮，我猜点它能成功。”这种预测是概率性的猜测。由于缺乏确认环节，一次微小的概率偏离（幻觉）就会导致流程彻底中断或产生错误后果。

RPA：在 RPA 脚本编写阶段，开发者已经对每一个按钮、每一个选择器（Selector）进行了显式确认。开发者在写 click("#submit_btn") 时，已经亲手点过并确认它能触发提交操作。这种“确认”被永久锁在了代码里。

#### 确认只适合于构建阶段而非执行阶段

在 Agent 执行流程操作时进行确认：不可行。且无法固化。

执行阶段的“确认成本”高：
- 如果在 Agent 每一个 Step 之后都要求人工或自我检查：
    - 效率低： 原本 10 秒的任务会因为反复确认拉长到数分钟。
    - 用户疲劳： 如果 Agent 每点一个按钮都问用户“我点对了吗？”，这便失去了自动化的意义。
- 无法固化：
    - 目前的 Agent 架构通常是“无状态”的。即便这一次它在某个步骤“猜对了”，下一次执行相同任务时，它依然要重新推理、重新猜测。它没有把“确认过正确”的信息转化为可复用的资产。

### “固化”是效率的来源

目前 Agent 的执行是**无状态（Stateless）**的。即便它曾成功完成过任务 A，下一次执行相同任务时，依然需要重新解析 DOM、重新推理逻辑。这种“重复思考”造成了计算资源的浪费。

能否像 RPA 一样，把 Agent 的“思考结果”固化下来？

这就是提出语义地图的原因——将“思考”留在地图构建期，将“速度”留在导航执行期。

## 解决方案

结合agent和rpa。把完整地图告诉agent,agent仅调用一次大模型,生成rpa脚本。

这就好比从“在一个陌生城市里靠直觉摸索”转变成了“先进行城市地图测绘，再根据地图进行导航”。
现在的agent
- 就像是一个初次来到异国他乡的游客。他能看懂路标（识别按钮），但他脑子里没有这张城市的全局地图。
- 每走到一个十字路口，他都要停下来分析路标 A、B、C 分别代表什么，然后猜测“去火车站应该走左边”。
- 他可能走进了死胡同，或者在原地绕圈。最关键的是，下一次他再去火车站，他还得重新分析一遍，因为他没有把路径固化下来。

构建地图：任务不是为了从 A 点到 B 点，而是为了跑遍全城的每一条路。

RPA：严格执行导航指令的自动驾驶车。它不需要理解为什么左转，它只需要接收指令：Drive(500m) -> TurnLeft -> Stop。速度极快：因为它跳过了所有“思考”和“分析路标”的时间，直接全速前进。

优点：不必为每个任务写rpa。正确性。速度快。
研究点：为网站构建完整地图。

## 如何构建地图

### 对Web应用的解构

Web 应用 $A$ 的最小功能单元是 **Element（元素）**，记为 $e$。一个 Web 应用可以被定义为所有可见及可交互元素的集合：
$$A = \{e_1, e_2, e_3, \dots, e_n\}$$

每个元素 $e_i$ 并非孤立存在，而是由三个维度构成的复合体：

*   **元素标识（Identity - 感知层）：**
    *   **定义：** 机器定位元素的物理路径或特征（如 CSS 选择器、XPath、ID）。
    *   **示例：** `login_button = tab.ele('.form-cut-item-btn')`
    *   **作用：** 解决“它在哪里”的问题，实现机器对页面的**物理感知**。

*   **元素操作（Action - 行动层）：**
    *   **定义：** 对元素施加的状态改变或交互指令。
    *   **示例：** `login_button.click()`
    *   **作用：** 解决“如何交互”的问题，定义交互原语（Click/Input/Select），触发页面的**状态转换**。

*   **元素含义（Semantics - 语义层）：**
    *   **定义：** 描述该元素在业务逻辑中的角色、前置条件及行为后果。
    *   **示例：** “在用户输入凭据后点击此按钮，验证通过后将跳转至【应用市场页】。”
    *   **作用：** 解决“它是做什么的”的问题，赋予操作以**业务含义**。描述业务角色、前置依赖及跳转后果。

通过对 Web 应用中原子元素 $e_i$ 进行上述三要素的建模，便可构建出一张**网页语义地图**，每个元素成为地图上的一个具有业务意义的节点。

### 构建机制

AI与人工相结合的网站语义地图构建。AI自动识别网页元素的语义/ID/可采取的动作。标注员能够进行检查和校正。
- 人类更适合处理元素的前提依赖（即语义层中的高级语义）。例如：只有输入了正确的订单号，才会出现“退款”按钮。
- 当自动探索失败时，自动通知标注员介入。人工点一下，系统自动记录这次“纠偏”，更新地图。
    - （构建地图的过程中，是允许探索和出错的，但实际运行流程自动化时，不行。）

## 架构

分为两个核心组件：
- Cartographer（绘图员）： 负责遍历网站，构建语义地图。
    - 本质是在逆向工程网站的业务逻辑状态机。
- Navigator（导航员）： 接收任务，查询语义地图，一次性生成 RPA 脚本。

### Cartographer（绘图员）

盲目遍历会导致陷入“死循环”（如万年历组件）。需要利用AI对网站的语义理解能力，优先点击有意义的元素。

### Navigator（导航员）

- 意图理解： 用户输入“我买的鼠标不好用，退钱。”。
    - 用户说“退钱”，地图上叫“申请售后”。Navigator利用AI的语义理解能力，能够正确识别用户的意图。
- 路径查找： 在语义地图中查找从首页到下载页的最短语义路径。
- RPA 生成： 将路径转化为 Python(DrissionPage) 代码一次性执行。

## 意义

- 当拥有了数百个政务系统的完整地图时，这本身就是巨大的数据资产。
    - 可进行跨业务系统的流程自动化。
- 当拥有了网站的完整地图时，相当于为通用大模型注入了领域专业知识。地图本身就是模型能力的补丁。