# 实验背景

实验18获得了查询焦点元素的代码，但是有很大压缩空间，这样的话方面控制台输入

# 实验目的

精简查询焦点元素代码

# 实验步骤

## 明确要精简的代码

```python
result = await cdp.send.Runtime.evaluate({
    "expression": """
        (function() {
            const focused = document.activeElement;
            if (!focused) return null;
            // 返回焦点元素的标签名、ID 和类名
            return {
                tagName: focused.tagName,
                id: focused.id,
                className: focused.className,
                outerHTML: focused.outerHTML.substring(0, 100)  // 截取部分 HTML
            };
        })()
    """,
    "returnByValue": True
}, session_id=sid)

if result["result"]["value"]:
    focused_info = result["result"]["value"]
    print("当前焦点元素信息：")
    print(f"标签名: {focused_info['tagName']}")
    print(f"ID: {focused_info['id']}")
    print(f"类名: {focused_info['className']}")
    print(f"HTML 片段: {focused_info['outerHTML']}")
else:
    print("当前无焦点元素")
```

## 问大模型：能否精简上述代码到1行，方便我在debug的时候在控制台输入

gemini 3 flash 的回复：

```python
cdp_session.cdp_client.send.Runtime.evaluate({"expression":"document.activeElement.id","returnByValue":True},session_id=cdp_session.session_id)['result']['value']
```

## 验证这行代码的有效性

```text
cdp_session.cdp_client.send.Runtime.evaluate({"expression":"document.activeElement.id","returnByValue":True},session_id=cdp_session.session_id)['result']['value']

<input>:1: RuntimeWarning: coroutine 'RuntimeClient.evaluate' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
Traceback (most recent call last):
  File "/home/zhbli/下载/pycharm-2025.3/plugins/python-ce/helpers/pydev/_pydevd_bundle/pydevd_exec2.py", line 3, in Exec
    exec(exp, global_vars, local_vars)
  File "<input>", line 1, in <module>
TypeError: 'coroutine' object is not subscriptable

await cdp_session.cdp_client.send.Runtime.evaluate({"expression":"document.activeElement.id","returnByValue":True},session_id=cdp_session.session_id)['result']['value']

  File "<input>", line 1
SyntaxError: 'await' outside function
```

### 分析错误原因

#### 分析1

cdp_session.cdp_client.send.Runtime.evaluate({"expression":"document.activeElement.id","returnByValue":True},session_id=cdp_session.session_id)

直接执行上述代码，pycharm控制台回复：

```bash
<input>:1: RuntimeWarning: coroutine 'RuntimeClient.evaluate' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
<coroutine object RuntimeClient.evaluate at 0x70c3d90f9a40>
```

但是这行代码应该返回的东西不对。

原因：直接执行得到的那个 `<coroutine object>` 是一个未执行的任务。要拿到里面的 id，你必须通过 await 来驱动这个任务执行。

#### 分析2

res = (await cdp_session.cdp_client.send.Runtime.evaluate({"expression":"document.activeElement.id","returnByValue":True}, session_id=cdp_session.session_id))

执行上述代码，pycharm控制台回复：

```bash
File "<input>", line 1
SyntaxError: 'await' outside function
```

解决方案：让pycharm调试控制台使用ipython。确认是否正在使用的方法：在pycharm调试控制台输入：

```
import sys
```

如果没有输出 `PyDev console: using IPython 9.8.0`，说明没有启用。安装即可：`pip install ipython`

安装后再执行：

```
res = (await cdp_session.cdp_client.send.Runtime.evaluate({"expression":"document.activeElement.id","returnByValue":True}, session_id=cdp_session.session_id))
PyDev console: using IPython 9.8.0
Traceback (most recent call last):
  File "/home/zhbli/miniconda3/envs/browser_use_source_py312/lib/python3.12/site-packages/IPython/core/interactiveshell.py", line 3178, in _run_cell
    result = runner(coro)
             ^^^^^^^^^^^^
  File "/home/zhbli/miniconda3/envs/browser_use_source_py312/lib/python3.12/site-packages/IPython/core/async_helpers.py", line 55, in __call__
    return get_asyncio_loop().run_until_complete(coro)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zhbli/miniconda3/envs/browser_use_source_py312/lib/python3.12/asyncio/base_events.py", line 667, in run_until_complete
    self._check_running()
  File "/home/zhbli/miniconda3/envs/browser_use_source_py312/lib/python3.12/asyncio/base_events.py", line 626, in _check_running
    raise RuntimeError('This event loop is already running')
RuntimeError: This event loop is already running
```

### 分析3

根据gemini的回复，找到进一步解决方案：

```python
import nest_asyncio
nest_asyncio.apply()

# 现在再运行你的代码就不会报错了
res = (await cdp_session.cdp_client.send.Runtime.evaluate(
    {"expression": "document.activeElement.id", "returnByValue": True}, 
    session_id=cdp_session.session_id
))
print(res)
```

这是可行的，返回结果：{'result': {'type': 'string', 'value': ''}} 说明此刻确实没有焦点。

## 进一步精简代码

```python
import nest_asyncio; nest_asyncio.apply(); (await cdp_session.cdp_client.send.Runtime.evaluate({"expression": "document.activeElement.id", "returnByValue": True}, session_id=cdp_session.session_id))
```

已经成功执行

# 实验结果

精简结果为 

```python
import nest_asyncio; nest_asyncio.apply(); (await cdp_session.cdp_client.send.Runtime.evaluate({"expression": "document.activeElement.id", "returnByValue": True}, session_id=cdp_session.session_id))
```

本实验任务完成。

# 未来计划

下一步要验证：正确情况能获取焦点，错误情况不能获取焦点，从而证明出问题的原因是焦点导致的。