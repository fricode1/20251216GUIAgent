# å®éªŒèƒŒæ™¯

agentæ“ä½œ12306æµè§ˆå™¨å¡«å†™æ—¶é—´æ¡†å¤±æ•ˆã€‚å¡«å†™æ“ä½œæ˜¯åŸºæœ¬æ“ä½œï¼Œå¦‚æœè¿™ä¸ªæ“ä½œéƒ½æä¸å®šï¼Œå°†æ¥èƒ½å‘æŒ¥ä»€ä¹ˆå¤§çš„ä½œç”¨å‘¢ï¼Ÿæ‰€ä»¥å¿…é¡»å¼„æ¸…æ¥šç©¶ç«Ÿæ˜¯æ€ä¹ˆå¤±æ•ˆçš„ã€‚åº•å±‚æ˜¯ç”¨ cdp use æ“ä½œçš„ã€‚

# å®éªŒç›®çš„

ç”¨ cdp_use å¤ç°12306å¡«å†™æ—¶é—´æ¡†å¤±æ•ˆã€‚

# å®éªŒæ­¥éª¤

## æµè§ˆ cdp_use ä»£ç 

- https://github.com/browser-use/cdp-use
- å€ŸåŠ©è±†åŒ…ã€‚

## è·‘é€š cdp_use ä»£ç 

### æœåŠ¡ç«¯

chromium --remote-debugging-port=9222

è¿è¡Œè¯¥å‘½ä»¤ï¼Œä¼šå¾—åˆ°ç›‘å¬åœ°å€ï¼Œå¦‚ï¼š`ws://[::1]:9222/devtools/browser/7119b24e-4638-4d1f-89ec-06fae1f66be5`

### å®¢æˆ·ç«¯

```python

import asyncio
from cdp_use.client import CDPClient

async def main():
    # Connect to Chrome DevTools
    async with CDPClient("ws://[::1]:9222/devtools/browser/7119b24e-4638-4d1f-89ec-06fae1f66be5") as cdp:
        # Get all browser targets with full type safety
        targets = await cdp.send.Target.getTargets()
        print(f"Found {len(targets['targetInfos'])} targets")
        for target in targets["targetInfos"]:
            print(f"ç›®æ ‡ID: {target['targetId']}, æ ‡é¢˜: {target['title']}, URL: {target['url']}")

asyncio.run(main())
```

å¤‡æ³¨ï¼š`async with CDPClient("ws://[::1]:9222/devtools/browser/7119b24e-4638-4d1f-89ec-06fae1f66be5") as cdp:`

åœ°å€ä»æœåŠ¡ç«¯è·å–ã€‚

æ³¨æ„ï¼Œå¦‚æœæŠ¥ 404 é”™è¯¯ï¼Œæ˜¯å› ä¸ºä½ é‡å¯äº†æœåŠ¡ç«¯ï¼Œä½†æ˜¯å®¢æˆ·ç«¯åœ°å€æ²¡æœ‰æ›´æ–°ã€‚

æˆåŠŸè·‘é€šã€‚

## è·‘é€šç‚¹å‡»ä»£ç 

æˆåŠŸã€‚

### åæ ‡æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

åœ¨ CDP (Chrome DevTools Protocol) ä¸­ï¼Œåæ ‡çš„å‚è€ƒç³»å’Œè¡Œä¸ºé€»è¾‘å¦‚ä¸‹ï¼Œè¿™å¯¹äºå¼€å‘ GUI Agent éå¸¸å…³é”®ï¼š

### 1. åæ ‡å‚è€ƒç³»ï¼šè§†å£ (Viewport)
CDP çš„ `Input.dispatchMouseEvent` å’Œ `DOM.getBoxModel` ä½¿ç”¨çš„æ˜¯**è§†å£åæ ‡ç³» (Viewport Coordinates)**ã€‚
*   **åŸç‚¹ (0,0)**ï¼šä½äºæµè§ˆå™¨å†…å®¹åŒºåŸŸï¼ˆä¸åŒ…å«æ ‡ç­¾æ ã€åœ°å€æ ã€ä¹¦ç­¾æ ï¼‰çš„**å·¦ä¸Šè§’**ã€‚
*   **å•ä½**ï¼šCSS åƒç´ ã€‚

---

### 2. ä¸åŒæ“ä½œå¯¹åæ ‡çš„å½±å“

#### â‘  æ‹–åŠ¨æµè§ˆå™¨çª—å£ï¼ˆåœ¨æ¡Œé¢ä¸Šç§»åŠ¨ï¼‰
*   **å½±å“ï¼šæ— **ã€‚
*   **åŸå› **ï¼šå› ä¸ºå‚è€ƒç³»æ˜¯æµè§ˆå™¨è§†å£çš„å·¦ä¸Šè§’ï¼Œè€Œä¸æ˜¯æ“ä½œç³»ç»Ÿçš„å±å¹•å·¦ä¸Šè§’ã€‚æ— è®ºä½ æŠŠæµè§ˆå™¨æ‹–åˆ°å“ªä¸ªæ˜¾ç¤ºå™¨æˆ–å“ªä¸ªè§’è½ï¼Œå…ƒç´ åœ¨è§†å£å†…çš„ `(x, y)` åæ ‡ä¿æŒä¸å˜ã€‚

#### â‘¡ æ»šåŠ¨ç½‘é¡µ (Scrolling)
*   **å½±å“ï¼šæœ‰ï¼Œåæ ‡ä¼šåŠ¨æ€å˜åŒ–**ã€‚
*   **åŸå› **ï¼š`DOM.getBoxModel` è¿”å›çš„æ˜¯å…ƒç´ å½“å‰ç›¸å¯¹äºè§†å£çš„ä½ç½®ã€‚
    *   å¦‚æœä¸€ä¸ªæŒ‰é’®åœ¨é¡µé¢é¡¶éƒ¨ï¼Œåæ ‡å¯èƒ½æ˜¯ `(100, 100)`ã€‚
    *   å½“ä½ å‘ä¸‹æ»šåŠ¨ 50 åƒç´ åï¼Œå†æ¬¡è°ƒç”¨ `getBoxModel`ï¼Œå®ƒçš„åæ ‡ä¼šå˜æˆ `(100, 50)`ã€‚
    *   **æ³¨æ„**ï¼šå¦‚æœä½ å‘é€ç‚¹å‡»æŒ‡ä»¤ç»™ä¸€ä¸ªå½“å‰**ä¸åœ¨è§†å£å†…**ï¼ˆæ»šå‡ºå»äº†ï¼‰çš„åæ ‡ï¼Œç‚¹å‡»å¯èƒ½ä¼šå¤±æ•ˆï¼Œæˆ–è€…ç‚¹åˆ°äº†é®æŒ¡åœ¨ä¸Šé¢çš„å…¶ä»–å…ƒç´ ã€‚

#### â‘¢ ç¼©æ”¾é¡µé¢ (Zooming, å¦‚ Ctrl + '+')
*   **å½±å“ï¼šæœ‰ï¼Œä½† CDP ä¼šè‡ªåŠ¨å¤„ç†æ¯”ä¾‹**ã€‚
*   **åŸå› **ï¼šCDP ä½¿ç”¨çš„æ˜¯ **CSS åƒç´ **ã€‚
    *   å½“ä½ æ”¾å¤§é¡µé¢åˆ° 200% æ—¶ï¼Œå…ƒç´ å ç”¨çš„ç‰©ç†åƒç´ å˜å¤šäº†ï¼Œä½†å®ƒåœ¨å¸ƒå±€ä¸­çš„é€»è¾‘ CSS åƒç´ ä¹Ÿä¼šéšä¹‹æ”¹å˜ã€‚
    *   å…³é”®ç‚¹ï¼š**åªè¦ä½ åœ¨ç‚¹å‡»å‰ç¬é—´è°ƒç”¨ `DOM.getBoxModel` è·å–åæ ‡ï¼Œæ‹¿åˆ°çš„å°±æ˜¯å½“å‰ç¼©æ”¾çŠ¶æ€ä¸‹çš„å‡†ç¡®åæ ‡**ï¼Œç›´æ¥å‘ç»™ `Input` å³å¯ï¼Œä¸éœ€è¦æ‰‹åŠ¨è®¡ç®—ç¼©æ”¾æ¯”ã€‚

#### â‘£ è°ƒæ•´æµè§ˆå™¨çª—å£å¤§å° (Resizing)
*   **å½±å“ï¼šæœ‰ï¼Œä¼šå¯¼è‡´é‡æ–°å¸ƒå±€ (Reflow)**ã€‚
*   **åŸå› **ï¼šæ”¹å˜çª—å£å®½åº¦å¯èƒ½ä¼šè§¦å‘å“åº”å¼å¸ƒå±€ï¼Œå¯¼è‡´æŒ‰é’®ä»å·¦è¾¹è·³åˆ°å³è¾¹ã€‚
    *   **å¯¹ç­–**ï¼šåœ¨æ‰§è¡Œç‚¹å‡»åŠ¨ä½œå‰ï¼Œé‡æ–°è°ƒç”¨ä¸€æ¬¡ `querySelector` å’Œ `getBoxModel` è·å–æœ€æ–°ä½ç½®ã€‚

---

### 3. å¼€å‘ GUI Agent çš„æœ€ä½³å®è·µ

ä¸ºäº†ä¿è¯ç‚¹å‡»çš„ 100% å‡†ç¡®ï¼Œå»ºè®®éµå¾ªä»¥ä¸‹æµç¨‹ï¼š

1.  **ç¡®ä¿å…ƒç´ åœ¨è§†å£å†…**ï¼š
    åœ¨ç‚¹å‡»å‰ï¼Œå…ˆè°ƒç”¨ `DOM.scrollIntoViewIfNeeded`ï¼ˆé€šè¿‡ `Runtime.evaluate`ï¼‰æˆ–è€…ä½¿ç”¨ CDP çš„ `DOM.scrollToIntoView`ã€‚
    ```python
    # ä¼ªä»£ç ï¼šç‚¹å‡»å‰å…ˆæ»šåŠ¨åˆ°è§†é‡å†…
    await cdp.send.Runtime.evaluate({
        "expression": "document.querySelector('selector').scrollIntoView({block: 'center'})"
    }, sessionId=sid)
    ```

2.  **å³æ‹¿å³ç”¨**ï¼š
    ä¸è¦ç¼“å­˜åæ ‡ã€‚ç½‘é¡µæ˜¯åŠ¨æ€çš„ï¼Œåæ ‡åº”è¯¥åœ¨ `Input.dispatchMouseEvent` ä¹‹å‰çš„å‡ æ¯«ç§’å†…é€šè¿‡ `getBoxModel` è·å–ã€‚

3.  **å¤„ç†â€œè§†å£å¤–â€çš„æƒ…å†µ**ï¼š
    å¦‚æœ `getBoxModel` è¿”å›çš„åæ ‡æ˜¯è´Ÿæ•°ï¼Œæˆ–è€…å¤§äºè§†å£é«˜åº¦ï¼ˆå¯ä»¥é€šè¿‡ `Page.getLayoutMetrics` è·å–è§†å£å®½é«˜ï¼‰ï¼Œè¯´æ˜å…ƒç´ ä¸å¯è§ï¼Œç‰©ç†ç‚¹å‡»ä¼šå¤±è´¥ã€‚

### æ€»ç»“
**CDP çš„åæ ‡æ˜¯â€œæ‰€è§å³æ‰€å¾—â€çš„è§†å£åæ ‡ã€‚** 
*   **ç§»åŠ¨çª—å£**ï¼šä¸å½±å“ã€‚
*   **æ»šåŠ¨/ç¼©æ”¾/è°ƒå¤§å°**ï¼šä¼šæ”¹å˜æ•°å€¼ã€‚
*   **è§£å†³æ–¹æ¡ˆ**ï¼šå…ˆæ‰§è¡Œ `scrollIntoView`ï¼Œç„¶åç«‹å³è·å– `getBoxModel` åæ ‡å¹¶ç‚¹å‡»ã€‚

## ç‚¹å‡» 12306 å‡ºå‘æ—¥æœŸ æ–‡æœ¬æ¡†

### ç¡®è®¤åæ ‡

çœ‹åŸå…ˆå®éªŒ4è·‘çš„12306æ—¥å¿—ï¼Œå¯ä»¥è·å¾—åæ ‡ã€‚æ­£å¥½éªŒè¯ä¸‹ä¸¤æ¬¡åæ ‡æ˜¯å¦ä¸€è‡´ã€‚

è·å¾—åæ ‡ï¼š x=657.0, y=369.0

### åœ¨ 12306 ä¸Šè·‘ cdp_use ä»£ç 

æ²¡æœ‰ååº”ã€‚

åº”è¯¥æ˜¯ä»£ç æœ‰è¯¯ã€‚æ”¹æˆåŸæ¥çš„ç‚¹å‡» selector = "a" å¥½åƒæ˜¯æœ‰æ•ˆã€‚æˆ‘åº”è¯¥å¼„æ‡‚ä»£ç å«ä¹‰ã€‚æˆ‘æƒ³è·‘é€š claude code + glmã€‚è®©å®ƒè§£è¯»ã€‚

è§£è¯»ç»“æœï¼š

```
> ä»€ä¹ˆæ˜¯CSSé€‰æ‹©å™¨ 

â— CSS é€‰æ‹©å™¨æ˜¯ä¸€ç§è¯­æ³•ï¼Œç”¨äºåœ¨ HTML é¡µé¢ä¸­å®šä½ç‰¹å®šçš„å…ƒç´ ã€‚

  åŸºæœ¬ç±»å‹

  | é€‰æ‹©å™¨ | è¯´æ˜          | ç¤ºä¾‹                              |
  |--------|---------------|-----------------------------------|
  | æ ‡ç­¾å | æŒ‰æ ‡ç­¾é€‰æ‹©    | aï¼ˆæ‰€æœ‰é“¾æ¥ï¼‰ã€divã€input         |
  | .ç±»å  | æŒ‰ class é€‰æ‹© | .btnï¼ˆclass="btn" çš„å…ƒç´ ï¼‰        |
  | #id    | æŒ‰ id é€‰æ‹©    | #usernameï¼ˆid="username" çš„å…ƒç´ ï¼‰ |
  | [å±æ€§] | æŒ‰å±æ€§é€‰æ‹©    | [type="text"]ã€[name="date"]      |

  ç»„åˆé€‰æ‹©å™¨

  | é€‰æ‹©å™¨ | è¯´æ˜       | ç¤ºä¾‹                        |
  |--------|------------|-----------------------------|
  | ç©ºæ ¼   | åä»£å…ƒç´    | div aï¼ˆdiv å†…çš„æ‰€æœ‰é“¾æ¥ï¼‰   |
  | >      | ç›´æ¥å­å…ƒç´  | ul > liï¼ˆul çš„ç›´æ¥å­ liï¼‰   |
  | ,      | å¤šä¸ªé€‰æ‹©å™¨ | a, buttonï¼ˆæ‰€æœ‰é“¾æ¥å’ŒæŒ‰é’®ï¼‰ |

  å®é™…ä¾‹å­

  å‡è®¾ HTML æ˜¯ï¼š
  <input id="train_date" class="input-text" name="date" type="text">

  åˆ™å¯ä»¥ç”¨ï¼š
  - #train_date â†’ é€šè¿‡ ID ç²¾ç¡®å®šä½
  - .input-text â†’ é€šè¿‡ class
  - input[name="date"] â†’ é€šè¿‡å±æ€§
  - input[type="text"] â†’ é€šè¿‡ç±»å‹

  æŸ¥çœ‹é€‰æ‹©å™¨çš„æ–¹æ³•

  åœ¨æµè§ˆå™¨ä¸­ï¼š
  1. å³é”®ç‚¹å‡»å…ƒç´  â†’ "æ£€æŸ¥"
  2. åœ¨ Elements é¢æ¿ä¸­å³é”®è¯¥å…ƒç´ 
  3. é€‰æ‹© "Copy" â†’ "Copy selector"
```

å°†ä»£ç æ”¹æˆ `#train_date`åï¼Œæœç„¶å¯ä»¥äº†ã€‚

## ä¸‹ä¸€æ­¥åšä»€ä¹ˆï¼Ÿ

æˆ‘å·²ç»è·‘é€šç‚¹å‡»ä»£ç ã€‚ä¸‹ä¸€æ­¥å¹²ä»€ä¹ˆå‘¢ï¼Ÿä½ æ€ä¹ˆçŸ¥é“å‡ºé”™çš„ä»£ç æ‰§è¡Œäº†ä¸Šè¿°ç‚¹å‡»ä»£ç å‘¢ï¼Ÿ

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘è¿™é‡Œä»åº•å±‚è·‘çš„ä»£ç è·Ÿå®éªŒå››çš„ä»£ç å¹¶æ²¡æœ‰å¯¹åº”å…³ç³»ã€‚åœ¨å®éªŒå››ä¸­ï¼Œæ–‡æœ¬è¾“å…¥é‚£é‡Œå·²ç»è·Ÿè¿›åˆ°äº†å¾ªç¯å­—ç¬¦çš„ç¨‹åº¦ã€‚æˆ‘è¦äº†è§£å¾ªç¯å­—ç¬¦è¾“å…¥çš„ä»£ç æƒ…å†µï¼Œå†æƒ³æƒ³å¦‚ä½•é€šè¿‡CDP åº•å±‚ä»£ç å¯¹æ¥ã€‚

## æŸ¥çœ‹æ–‡æœ¬å¾ªç¯è¾“å…¥ä»£ç 

```python
async def _input_text_element_node_impl(  
    self, element_node: EnhancedDOMTreeNode, text: str, clear: bool = True, is_sensitive: bool = False  
) -> dict | None:  
    """  
    Input text into an element using pure CDP with improved focus fallbacks.  
    For date/time inputs, uses direct value assignment instead of typing.    """  
    try:  
       # Get CDP client  
       cdp_client = self.browser_session.cdp_client  
  
       # Get the correct session ID for the element's iframe  
       # session_id = await self._get_session_id_for_element(element_node)  
       # cdp_session = await self.browser_session.get_or_create_cdp_session(target_id=element_node.target_id, focus=True)       cdp_session = await self.browser_session.cdp_client_for_node(element_node)  
  
       # Get element info  
       backend_node_id = element_node.backend_node_id  
  
       # Track coordinates for metadata  
       input_coordinates = None  
  
       # Scroll element into view  
       try:  
          await cdp_session.cdp_client.send.DOM.scrollIntoViewIfNeeded(  
             params={'backendNodeId': backend_node_id}, session_id=cdp_session.session_id  
          )  
          await asyncio.sleep(0.01)  
       except Exception as e:  
          # Node detached errors are common with shadow DOM and dynamic content  
          # The element can still be interacted with even if scrolling fails          error_str = str(e)  
          if 'Node is detached from document' in error_str or 'detached from document' in error_str:  
             self.logger.debug(  
                f'Element node temporarily detached during scroll (common with shadow DOM), continuing: {element_node}'  
             )  
          else:  
             self.logger.debug(f'Failed to scroll element {element_node} into view before typing: {type(e).__name__}: {e}')  
  
       # Get object ID for the element  
       result = await cdp_client.send.DOM.resolveNode(  
          params={'backendNodeId': backend_node_id},  
          session_id=cdp_session.session_id,  
       )  
       assert 'object' in result and 'objectId' in result['object'], (  
          'Failed to find DOM element based on backendNodeId, maybe page content changed?'  
       )  
       object_id = result['object']['objectId']  
  
       # Get current coordinates using unified method  
       coords = await self.browser_session.get_element_coordinates(backend_node_id, cdp_session)  
       if coords:  
          center_x = coords.x + coords.width / 2  
          center_y = coords.y + coords.height / 2  
  
          # Check for occlusion before using coordinates for focus  
          is_occluded = await self._check_element_occlusion(backend_node_id, center_x, center_y, cdp_session)  
  
          if is_occluded:  
             self.logger.debug('ğŸš« Input element is occluded, skipping coordinate-based focus')  
             input_coordinates = None  # Force fallback to CDP-only focus  
          else:  
             input_coordinates = {'input_x': center_x, 'input_y': center_y}  
             self.logger.debug(f'Using unified coordinates: x={center_x:.1f}, y={center_y:.1f}')  
       else:  
          input_coordinates = None  
          self.logger.debug('No coordinates found for element')  
  
       # Ensure we have a valid object_id before proceeding  
       if not object_id:  
          raise ValueError('Could not get object_id for element')  
  
       # Step 1: Focus the element using simple strategy  
       focused_successfully = await self._focus_element_simple(  
          backend_node_id=backend_node_id, object_id=object_id, cdp_session=cdp_session, input_coordinates=input_coordinates  
       )  
  
       # Step 2: Check if this element requires direct value assignment (date/time inputs)  
       requires_direct_assignment = self._requires_direct_value_assignment(element_node)  
  
       if requires_direct_assignment:  
          # Date/time inputs: use direct value assignment instead of typing  
          self.logger.debug(  
             f'ğŸ¯ Element type={element_node.attributes.get("type")} requires direct value assignment, setting value directly'          )  
          await self._set_value_directly(element_node, text, object_id, cdp_session)  
  
          # Return input coordinates for metadata  
          return input_coordinates  
  
       # Step 3: Clear existing text if requested (only for regular inputs that support typing)  
       if clear:  
          cleared_successfully = await self._clear_text_field(object_id=object_id, cdp_session=cdp_session)  
          if not cleared_successfully:  
             self.logger.warning('âš ï¸ Text field clearing failed, typing may append to existing text')  
  
       # Step 4: Type the text character by character using proper human-like key events  
       # This emulates exactly how a human would type, which modern websites expect       if is_sensitive:  
          # Note: sensitive_key_name is not passed to this low-level method,  
          # but we could extend the signature if needed for more granular logging          self.logger.debug('ğŸ¯ Typing <sensitive> character by character')  
       else:  
          self.logger.debug(f'ğŸ¯ Typing text character by character: "{text}"')  
  
       for i, char in enumerate(text):  
          # Handle newline characters as Enter key  
          if char == '\n':  
             # Send proper Enter key sequence  
             await cdp_session.cdp_client.send.Input.dispatchKeyEvent(  
                params={  
                   'type': 'keyDown',  
                   'key': 'Enter',  
                   'code': 'Enter',  
                   'windowsVirtualKeyCode': 13,  
                },  
                session_id=cdp_session.session_id,  
             )  
  
             # Small delay to emulate human typing speed  
             await asyncio.sleep(0.001)  
  
             # Send char event with carriage return  
             await cdp_session.cdp_client.send.Input.dispatchKeyEvent(  
                params={  
                   'type': 'char',  
                   'text': '\r',  
                   'key': 'Enter',  
                },  
                session_id=cdp_session.session_id,  
             )  
  
             # Send keyUp event  
             await cdp_session.cdp_client.send.Input.dispatchKeyEvent(  
                params={  
                   'type': 'keyUp',  
                   'key': 'Enter',  
                   'code': 'Enter',  
                   'windowsVirtualKeyCode': 13,  
                },  
                session_id=cdp_session.session_id,  
             )  
          else:  
             # Handle regular characters  
             # Get proper modifiers, VK code, and base key for the character             modifiers, vk_code, base_key = self._get_char_modifiers_and_vk(char)  
             key_code = self._get_key_code_for_char(base_key)  
  
             # self.logger.debug(f'ğŸ¯ Typing character {i + 1}/{len(text)}: "{char}" (base_key: {base_key}, code: {key_code}, modifiers: {modifiers}, vk: {vk_code})')  
             # Step 1: Send keyDown event (NO text parameter)             await cdp_session.cdp_client.send.Input.dispatchKeyEvent(  
                params={  
                   'type': 'keyDown',  
                   'key': base_key,  
                   'code': key_code,  
                   'modifiers': modifiers,  
                   'windowsVirtualKeyCode': vk_code,  
                },  
                session_id=cdp_session.session_id,  
             )  
  
             # Small delay to emulate human typing speed  
             await asyncio.sleep(0.005)  
  
             # Step 2: Send char event (WITH text parameter) - this is crucial for text input  
             await cdp_session.cdp_client.send.Input.dispatchKeyEvent(  
                params={  
                   'type': 'char',  
                   'text': char,  
                   'key': char,  
                },  
                session_id=cdp_session.session_id,  
             )  
  
             # Step 3: Send keyUp event (NO text parameter)  
             await cdp_session.cdp_client.send.Input.dispatchKeyEvent(  
                params={  
                   'type': 'keyUp',  
                   'key': base_key,  
                   'code': key_code,  
                   'modifiers': modifiers,  
                   'windowsVirtualKeyCode': vk_code,  
                },  
                session_id=cdp_session.session_id,  
             )  
  
          # Small delay between characters to look human (realistic typing speed)  
          await asyncio.sleep(0.001)  
  
       # Step 4: Trigger framework-aware DOM events after typing completion  
       # Modern JavaScript frameworks (React, Vue, Angular) rely on these events       # to update their internal state and trigger re-renders       await self._trigger_framework_events(object_id=object_id, cdp_session=cdp_session)  
  
       # Return coordinates metadata if available  
       return input_coordinates  
  
    except Exception as e:  
       self.logger.error(f'Failed to input text via CDP: {type(e).__name__}: {e}')  
       raise BrowserError(f'Failed to input text into element: {repr(element_node)}')
```

# å®éªŒç»“æœ

æƒ³è¦è¾¾åˆ°å®éªŒç›®çš„æ˜¯å¾ˆéš¾çš„ã€‚éœ€è¦åç»­å®éªŒè¿›ä¸€æ­¥å¼„æ¸…æ¥šã€‚