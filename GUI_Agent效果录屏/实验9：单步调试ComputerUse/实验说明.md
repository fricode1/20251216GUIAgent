# 实验背景

12306网站日期窗口由于失去焦点导致无法填写，我需要确定为什么。单步调试是个好方法。

# 实验目标

通过单步调试找出失去焦点的原因

# 实验步骤

## 准备好代码

 完成
## 失败：再次确认能够复现错误

需要给模型充钱

## 给模型充钱

充钱5元完成。

## 继续：再次确认能够复现错误

确实能够复现填写不进去的失败

## 单步调试

定位到填写那里 `_input_text_element_node_impl`。按理说应该是不成功的。且填写时窗口没有焦点。

失去焦点的代码位于 `browser_use/browser/watchdogs/default_action_watchdog.py` 1525~1552 行之间。

## 缩小失去焦点的代码范围

1539 行代码 `cleared_successfully = await self._clear_text_field(object_id=object_id, cdp_session=cdp_session)` 导致失去焦点。

说明是 `_clear_text_field` 函数导致的。

## 进入 `_clear_text_field` 函数调试，进一步缩小失去焦点的代码范围

1055行导致失去焦点。

```python
clear_result = await cdp_session.cdp_client.send.Runtime.callFunctionOn(
    params={
        'functionDeclaration': """
            function() {
                // Check if it's a contenteditable element
                const hasContentEditable = this.getAttribute('contenteditable') === 'true' ||
                                        this.getAttribute('contenteditable') === '' ||
                                        this.isContentEditable === true;

                if (hasContentEditable) {
                    // For contenteditable elements, clear all content
                    while (this.firstChild) {
                        this.removeChild(this.firstChild);
                    }
                    this.textContent = "";
                    this.innerHTML = "";

                    // Focus and position cursor at the beginning
                    this.focus();
                    const selection = window.getSelection();
                    const range = document.createRange();
                    range.setStart(this, 0);
                    range.setEnd(this, 0);
                    selection.removeAllRanges();
                    selection.addRange(range);

                    // Dispatch events
                    this.dispatchEvent(new Event("input", { bubbles: true }));
                    this.dispatchEvent(new Event("change", { bubbles: true }));

                    return {cleared: true, method: 'contenteditable', finalText: this.textContent};
                } else if (this.value !== undefined) {
                    // For regular inputs with value property
                    try {
                        this.select();
                    } catch (e) {
                        // ignore
                    }
                    this.value = "";
                    this.dispatchEvent(new Event("input", { bubbles: true }));
                    this.dispatchEvent(new Event("change", { bubbles: true }));
                    return {cleared: true, method: 'value', finalText: this.value};
                } else {
                    return {cleared: false, method: 'none', error: 'Not a supported input type'};
                }
            }
        """,
        'objectId': object_id,
        'returnByValue': True,
    },
    session_id=cdp_session.session_id,
)
```

## 问问 claude等大模型，为什么这些代码会导致文本框失去焦点

两个模型都提到了可能是change事件的影响。

我可以在浏览器中执行一下这些代码吗？因为我之前在好像在浏览器执行过类似代码。我要确认能不能这么做。

## 确认上述代码是否能直接在浏览器中执行

这段代码中的 **JavaScript 逻辑部分** 是标准的 Web API，**可以在浏览器中执行**，但不能直接原样粘贴，需要做一点小调整。

原因在于：在 CDP（Chrome DevTools Protocol）中，callFunctionOn 会自动将 this 绑定到指定的 DOM 元素上。如果你直接在浏览器控制台（F12 Console）粘贴这段匿名函数，this 会指向 window 对象，导致代码报错。

## 尝试在浏览器中执行这些代码

```JavaScript
(function() {
    // 定位你的文本框
    const el = document.getElementById('train_date');
    if (!el) return "找不到元素";

    // 1. 显式获取焦点
    el.focus();

    // 2. 清空值
    el.value = "";

    // 3. 针对 input 元素，确保光标位置在开头
    if (el.setSelectionRange) {
        el.setSelectionRange(0, 0);
    }

    // 4. 触发事件 (先触发 input，后触发 change)
    el.dispatchEvent(new Event("input", { bubbles: true }));
    el.dispatchEvent(new Event("change", { bubbles: true }));

    // 5. 关键补丁：再次强化焦点（防止插件在 change 事件里夺走焦点）
    setTimeout(() => {
        el.focus();
        console.log("焦点已恢复");
    }, 10);

    return "清理完成并尝试维持焦点";
})();
```

能运行，且没有货得到焦点

## 失败：在浏览器中执行获取焦点的js

```JavaScript
(function() {
    // 定位你的文本框
    const el = document.getElementById('train_date');
    if (!el) return "找不到元素";

    // 1. 显式获取焦点
    el.focus();
})();
```

无法获取焦点。

## 问大模型如何用js获取元素el的焦点

```JavaScript
// 步骤1：获取目标元素（替换为你的选择器）
const el = document.getElementById('fromStationText');

// 步骤2：检查并修复焦点条件
if (!el) {
  console.error('元素不存在');
} else if (el.disabled) {
  el.disabled = false;
  console.log('已取消元素禁用');
} else if (el.tabIndex === -1 && !el.href && !el.contentEditable) {
  el.tabIndex = 0;
  console.log('已设置元素可聚焦');
} else if (getComputedStyle(el).display === 'none') {
  el.style.display = 'block';
  console.log('已显示元素');
}

// 步骤3：强制聚焦并验证
el.focus();
const isFocused = document.activeElement === el;
console.log('聚焦是否成功：', isFocused);
if (!isFocused) {
  // 兜底：模拟用户交互触发聚焦（需手动点击页面）
  document.addEventListener('click', () => {
    el.focus();
    console.log('点击后聚焦状态：', document.activeElement === el);
  }, { once: true });
  console.log('请点击页面任意位置重试');
}
```

## 失败：运行获取焦点代码

console.log 没有任何输出

## console.log 没有输出的原因

在 chrome 上不行，在 firefox 上就行。

## 终止：在 firefox 运行获取焦点代码

有新收获

## 判断是否聚焦的办法

document.activeElement 能够返回当前聚焦的元素

执行 el.focus() 后，确实能聚焦。但是，为什么窗口没有变蓝色？我需要试试在focus状态下输入文本能否成功。

## 如何用js输入文本

el.value = '123' 直接赋值即可. 不获取焦点也能直接赋值。

## 阶段性总结

文本框获取focus后也没变蓝色。不获取focus也能赋值。

问大模型：我手动点击一个网页的文本框，其边缘会变蓝色。为什么通过js框获取focus后没有变蓝色？

我突然想到，我可以一步步调试js代码，看哪里导致失效的。——这个不好调试。因为我一点击其他地方，该窗口就失去焦点了。——需要靠代码实现。

还有，为什么不点击那一下，就能获取焦点呢？

将 '在12306.cn 点击 出发日期 列表，输入 2025-12-31' 改为 '在12306.cn 的出发日期输入 2025-12-31' 确实可以输入。

# 实验结果

确认了是js代码导致的。注意：
- 如果不点击一下，js不会导致问题。
- 文本框获取focus后也没变蓝色。不获取focus也能赋值。
本应进一步调试，但是由于
- 是纯文本的js代码
- 在控制台操作的话文本框会立刻失去蓝色

所以无法基于本代码进一步调试，需要转换成cdp_use进一步调试。