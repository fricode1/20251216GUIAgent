# 实验背景

两个插件都有问题。我想改造却无从下手。因为我对插件开发一无所知。通过写 helloworld 就知道怎么改造了

# 实验目的

写浏览器插件

# 实验步骤

## 写 helloworld

实现浏览器插件，在侧边栏输出helloworld

## 技术难点

使用直接的方式向文本框输入文本，可能导致失败。这是可以预料的。因为直接设置value可能的问题：
- ⚠️ 某些框架（React、Vue）可能监听不到
- ⚠️ 反爬虫检测风险高

在类似产品（nanobrowser）是如何解决这个问题的：
- 使用 puppeteer-core (v24.31.0) - 轻量级 Puppeteer，不捆~绑 Chromium
- 通过 ExtensionTransport 连接到 Chrome 扩展已打开的标签页

Puppeteer 是 Google 官方推出的、基于 Node.js 的 Chrome/Chromium 自动化工具。Puppeteer 必须依赖 Node.js 运行。因为它本身是 Node.js 的一个 npm 包。

但是，为什么我在用浏览器插件的时候，该插件可以直接基于puppeteer操作网页，而不需要我运行 node 指令呢？

但在浏览器扩展中，Chrome 专门为开发者提供了一个名为 chrome.debugger 的原生 API。
它的功能： 允许扩展程序直接附加（Attach）到当前的标签页，并直接发送 CDP (Chrome DevTools Protocol) 指令。
它的意义： 既然扩展已经在浏览器内部了，它就不再需要通过网络（WebSocket）去绕一圈，而是直接走浏览器的内部通信。

```
浏览器扩展可以直接使用 Puppeteer：

  核心原理对比

  传统 Puppeteer (需要 Node.js)

  # 传统方式
  node script.js  → 启动 Node.js 进程
                 → Puppeteer 启动新的 Chromium 实例
                 → 通过 WebSocket 连接到 Chromium

  流程：
  Node.js 进程
    └─> puppeteer.launch()
         └─> 启动独立的 Chromium
         └─> WebSocket 连接 (ws://localhost:9222)

  Nanobrowser 扩展 (不需要 Node.js)

  // page.ts:107-108
  const browser = await connect({
    transport: await ExtensionTransport.connectTab(this._tabId),
    protocol: 'cdp' as ProtocolType,
  });

  关键区别：

  Chrome 浏览器
    ├─> 标签页 (用户已打开的网页)
    │     └─> chrome.debugger API (内置)
    │
    └─> Nanobrowser 扩展
          └─> Service Worker (运行 JavaScript)
                └─> puppeteer-core-browser.js
                      └─> ExtensionTransport
                            └─> chrome.debugger API

  关键技术点

  1. puppeteer-core-browser.js (page.ts:9)

  import {
    connect,
    ExtensionTransport,
  } from 'puppeteer-core/lib/esm/puppeteer/puppeteer-core-browser.js';

  这是专为浏览器环境构建的 Puppeteer 版本，特点：
  - ✅ 不依赖 Node.js 的 fs、path、child_process 等模块
  - ✅ 使用 ES Module 格式，浏览器可直接运行
  - ✅ 通过 Vite 打包成 background.iife.js

  2. ExtensionTransport 代替 WebSocket

  // 传统 Node.js Puppeteer
  const browser = await puppeteer.launch();  // 启动浏览器

  // Nanobrowser 扩展
  const browser = await connect({
    transport: await ExtensionTransport.connectTab(tabId),
    //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //           不启动新浏览器，连接到已打开的标签页
  });

  ExtensionTransport 内部实现（简化版）：

  class ExtensionTransport {
    static async connectTab(tabId) {
      // 1. 使用 Chrome Debugger API 附加到标签页
      await chrome.debugger.attach({ tabId }, '1.3');

      return {
        send: async (method, params) => {
          // 2. 通过 chrome.debugger 发送 CDP 命令
          await chrome.debugger.sendCommand({ tabId }, method, params);
        },
        on: (event, callback) => {
          // 3. 监听调试事件
          chrome.debugger.onEvent.addListener((source, method, params) => {
            if (method === event) callback(params);
          });
        }
      };
    }
  }

  3. Chrome Debugger API

  关键代码在 index.ts:40-48：

  // 监听调试器分离事件
  chrome.debugger.onDetach.addListener(async (source, reason) => {
    console.log('Debugger detached:', source, reason);
    if (reason === 'canceled_by_user') {
      if (source.tabId) {
        currentExecutor?.cancel();
        await browserContext.cleanup();
      }
    }
  });

  Chrome Debugger API 是 Chrome 扩展的内置功能：
  - 允许扩展附加到任何标签页
  - 直接发送 Chrome DevTools Protocol (CDP) 命令
  - 不需要 WebSocket 或 Node.js

  4. 通信流程

  ┌─────────────────────────────────────────────────────┐
  │              Chrome 浏览器进程                       │
  ├─────────────────────────────────────────────────────┤
  │                                                     │
  │  ┌─────────────┐        chrome.debugger API        │
  │  │  标签页 12  │ ◄────────────────────────────►  │
  │  │ (网页内容)  │      CDP 命令 (不经过网络)      │
  │  └─────────────┘                                    │
  │                                                     │
  │  ┌─────────────────────────────┐                   │
  │  │  Nanobrowser 扩展            │                   │
  │  │  (Service Worker)           │                   │
  │  │                             │                   │
  │  │  puppeteer-core-browser.js  │                   │
  │  │    ↓                        │                   │
  │  │  ExtensionTransport         │                   │
  │  │    ↓                        │                   │
  │  │  chrome.debugger.sendCommand│                   │
  │  └─────────────────────────────┘                   │
  └─────────────────────────────────────────────────────┘

  5. 为什么不需要 Node.js？

  | 传统 Puppeteer                | Nanobrowser 扩展                      |
  |-------------------------------|---------------------------------------|
  | Node.js 进程                  | Service Worker (浏览器内置 JS 运行时) |
  | puppeteer.launch() 启动浏览器 | 连接到用户已打开的标签页              |
  | WebSocket 通信                | chrome.debugger API（内存通信）       |
  | 需要 npm install              | 扩展已打包所有依赖                    |
  | 独立的 Chromium 进程          | 使用用户当前的 Chrome                 |

  打包过程

  查看 vite.config.mts:46-52：

  build: {
    lib: {
      formats: ['iife'],  // 立即执行函数表达式
      entry: 'src/background/index.ts',
      name: 'BackgroundScript',
      fileName: 'background',
    },
    rollupOptions: {
      external: ['chrome'],  // chrome API 不打包
    },
  }

  Vite 将：
  1. puppeteer-core-browser.js + 你的代码
  2. 打包成 dist/background.iife.js
  3. Service Worker 直接加载这个文件运行

  总结

  为什么不需要运行 Node.js？

  1. Service Worker 替代 Node.js：Chrome 扩展的 Service Worker 本身就是 JavaScript 运行环境
  2. puppeteer-core-browser：专为浏览器环境构建的 Puppeteer，移除了所有 Node.js 依赖
  3. chrome.debugger API：Chrome 内置的调试接口，替代 WebSocket
  4. ExtensionTransport：将 CDP 命令通过 chrome.debugger 发送，而不是网络请求

  整个自动化完全在单个 Chrome 进程内完成，没有跨进程通信，这就是为什么它如此高效且不需要额外运行时！
  ```


  page.ts()  attachpuppeteer 参考这个文件的实现，不用websocket，改用 puppeteer-core 中的 ExtensionTransport 

  但是让大模型写了多次，都不对。

  # 实验结果

  想靠AI从头开始完成现有nanobrowser的效果，难度太高，行不通。 