# 实验背景

已经明确是 change 导致的。接下来需要解决的是为什么点击一下会导致 change 的破坏。我需要在浏览器模拟。

# 实验目的

在浏览器模拟如下两种状态：
1. 获取文本框元素 - 点击文本框 - 获取焦点 - 查看焦点（应该不在文本框） - 清空文本 - change - 查看焦点（应该不在文本框）
2. 获取文本框元素 - 查看焦点（应该不在文本框） - 清空文本 - change - 查看焦点（应该在文本框）

# 实验步骤

## 明确在浏览器控制台的基本js操作

获取元素	var el = document.getElementById('train_date');
点击元素	el.click(); 或 el.focus();
查看页面焦点	document.activeElement (返回当前获得焦点的元素)
清空文本	el.value = "";
触发 change	el.dispatchEvent(new Event("change", { bubbles: true }));

## 组合成状态1

点击 + 清空 + change = 失去焦点

```JavaScript
(function() {
    var iframe = document.createElement('iframe');
    document.body.appendChild(iframe);
    console.log = iframe.contentWindow.console.log;
    var el = document.getElementById('train_date');
    
    // 1. 点击文本框
    el.focus();
    el.click();
    // el.dispatchEvent(new Event("change", { bubbles: true }));
    console.log("1. 初始焦点是否在文本框:", document.activeElement === el);

    // 2. 清空并触发 change
    el.value = "";
    console.log("2. 正在执行 change...");
    el.dispatchEvent(new Event("input", { bubbles: true }));
    el.dispatchEvent(new Event("change", { bubbles: true }));

    // 3. 再次查看焦点
    setTimeout(() => {
        console.log("3. 执行 change 后焦点是否还在文本框:", document.activeElement === el);
        console.log("   当前焦点实际在:", document.activeElement);
    }, 50); // 稍微延迟以等待框架可能的渲染耗时
})();
```

## 组合成状态2

无点击 + 清空 + change = 不失去焦点

```JavaScript
(function() {
    var iframe = document.createElement('iframe');
    document.body.appendChild(iframe);
    console.log = iframe.contentWindow.console.log;
    var el = document.getElementById('train_date');
    el.focus();
    // 1. 确保初始焦点不在文本框（点一下 body）
    console.log("1. 初始焦点是否在文本框:", document.activeElement == el);

    // 2. 清空并触发 change
    el.value = "";
    console.log("2. 正在执行 change...");
    el.dispatchEvent(new Event("input", { bubbles: true }));
    el.dispatchEvent(new Event("change", { bubbles: true }));

    // 3. 再次查看焦点
    setTimeout(() => {
        console.log("3. 执行后焦点是否在文本框:", document.activeElement == el);
        console.log("   当前焦点实际在:", document.activeElement);
    }, 50);
})();
```

## 组合成状态3

点击 + 清空 + 不change = 不失去焦点

```JavaScript
(function() {
    var iframe = document.createElement('iframe');
    document.body.appendChild(iframe);
    console.log = iframe.contentWindow.console.log;
    var el = document.getElementById('train_date');
    
    // 1. 点击文本框
    el.focus();
    el.click();
    // el.dispatchEvent(new Event("change", { bubbles: true }));
    console.log("1. 初始焦点是否在文本框:", document.activeElement === el);

    // 2. 清空并触发 change
    el.value = "";
    console.log("2. 正在执行 change...");
    el.dispatchEvent(new Event("input", { bubbles: true }));
    // el.dispatchEvent(new Event("change", { bubbles: true }));

    // 3. 再次查看焦点
    setTimeout(() => {
        console.log("3. 执行 change 后焦点是否还在文本框:", document.activeElement === el);
        console.log("   当前焦点实际在:", document.activeElement);
    }, 50); // 稍微延迟以等待框架可能的渲染耗时
})();
```

## 解决 log 无法输出的问题

原因是网站刻意屏蔽了。解决方案：

```JavaScript
var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
console.log = iframe.contentWindow.console.log;
// 然后再试
console.log("1");
```

# 结论

终于在控制台复现了3种情况。真厉害。接下来要搞懂为什么会这样。